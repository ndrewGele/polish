# BASE: Libraries
# HELP: Import our needed libraries here
library(shiny)
library(polish)

# BASE: Global Environment
# HELP: Global objects can be defined here if you want.
# HELP: If you aren't familiar with this concept, you can simply ignore this or refer to https://shiny.rstudio.com/articles/scoping.html for more info.

# BASE: Shiny Server
# HELP: Create our Shiny Server object, just like you normally would.
server <- function(input, output, session) {

  # HELP: Server code files will be loaded if they exist, which can be used to run reactive functions.
  # HELP: This example app has one module with a server.R file and one module without.
  modularServer(
    module.dir = file.path('.', 'modules'),
    module.file = 'server.R',
    environment = environment()
  )

  # HELP: Create a reactive UI output object.
  # HELP: Even if the app content is static, there shouldn't a significant performance impact.
  output$appUI <- renderUI({

    # HELP: UI is generated by this polish function, pulling in UI files from all of your module directories.
    modularUI(
      module.dir = file.path('.', 'modules'),
      module.file = 'ui.R',
      # HELP: Prefixing your modules with numbers will tell polish to arrange them in that order.
      numbered = TRUE,
      # HELP: This layout function can be swapped for other Shiny Layouts.
      layout.fun = navbarPage,
      # HELP: Additional arguments are passed to the layout function.
      title = 'My Modular App',
      theme = 'styles.css'
    )

  })

}

# BASE: Shiny UI
# HELP: The Shiny UI object just loads the UI Output object we create inside of the server.
ui <- uiOutput('appUI')

# BASE: App
# HELP: Lastly, we just run the shinyApp function, as usual.
shinyApp(ui, server)
